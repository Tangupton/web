一、五种I/O模型

socket缓冲区：每个socket被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。

write()/read()并不立即向网络中传输数据，而是先将数据写入缓冲区。当发送端应用程序使用write函数向一个TCP连接写入数据时，内核中的TCP模块首先把用户缓冲区的数据复制到与该连接对应的TCP内核发送缓冲区中，当内核发送缓冲区的数据达到一定值或者时间到时就想网络中发送数据。

read函数也类似分成两个阶段：

    等待数据在网络中传输到内核缓冲区
    从内核缓冲区向用户缓冲区复制数据

Unix一共分为五种I/O模型

    阻塞式I/O
    非阻塞式I/O
    I/O复用(select、poll、epoll)
    信号驱动I/O(SIGIO)
    异步IO（AIO）

阻塞式I/O

应用程序被阻塞，直到数据复制到应用进程缓冲区中才返回。但是，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞，因为还有其它程序可以执行，所以不消耗CPU时间，这种模型的CPU利用率会比较高。
非阻塞式I/O

应用程序执行系统调用后，内核返回一个错误码(对于accept、send和recv而言，errno通常被设置成EAGAIN或者EWOULDBLOCK；对于connect而言，errno则被设置成EINPOGRESS)。应用程序可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式被称为轮询(polling)。

由于CPU要处理更多的系统调用，因此这种模型的CPU率用来是比较低的。
I/O复用

使用select或者poll等待数据，并且可以等待多个套接字的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。

它可以让单个进程具有处理多个I/O时间的能力。又被称为事件驱动I/O。

如果一个Web服务器没有I/O复用，那么每一个socket连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O复用不需要进程线程创建和切换的开销，系统开销更小。
信号驱动I/O

应用程序使用sigaction系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞。内核在数据到达时向应用进程发送SIGIO信号，应用进程收到之后在信号处理程序中调用recvfrom将数据从内核复制到应用进程缓冲区中。

相比于非阻塞式I/O的轮询方式，信号驱动I/O的CPU利用率更高。
异步IO

应用进程执行aio_read系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步I/O与信号驱动I/O的区别在于，异步I/O的信号是通知应用进程I/O已经完成了，而信号驱动I/O的信号是通知应用进程可以开始I/O
二、epoll模型

Linux内核2.6后开始支持epoll，也是本服务器的核心。epoll模型中内核相当于监控代理，监控的粒度为每一个事件，我们把每个完整的处理过程分拆成了多个独立的事件并在epoll中注册，epoll的底层数据结构为一颗红黑树，当我们注册一个事件的时候就相当于把该事件挂在红黑树上，之后监控是否有事件发生的任务就交给内核来做，一旦检测到事件就分发到相应的处理模块。就HTTP服务器而言，可以分为以下几步。在创建了epoll之后

    首先需要注册响应的“监听”事件，之后不需要一直等待下去，直接返回。
    一旦内核监听到请求就会自动通知可以去建立连接并创建连接描述符，该连接描述符被注册为“读事件”，之后立即返回。
    用户发送的数据到达服务器，内核检测到读事件，建立任务并放入线程池中。之后唤醒等待任务队列中的工作线程来执行响应操作。

之所以选择epoll模型是因为事件驱动适合I/O密集型操作，而HTTP服务器最核心的任务就是响应请求的数据，设计大量I/O请求。另外当并发量上来之后，传统的多进程、多线程模型虽然并发量很大，但大多处于阻塞状态，即使多为就绪态，系统调度开销也非常大，因此这里使用事件驱动模型无疑更合适。

综上，整个服务器核心架构就是同步事件循环+非阻塞I/O+线程池，即Reactor模型。

Reactor模式工作流程

    主线程往epoll内核事件表中注册socket上的读就绪事件。
    主线程调用epoll_wait等待socket上有数据可读。
    当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列
    睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
    主线程调用epoll_wait等待socket可写。
    当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。
    睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。

是否同步指的是产生I/O的线程是否会一直等到I/O完成（I/O是否为当前线程完成），若会一直等待I/O完成则是同步I/O，如果将I/O任务"委派"给其他线程完成并通过回调方式通知调用者（即产生I/O线程可以和执行I/O线程并发），此时就是异步。这里是否是阻塞式I/O指的是read或write等系统调用在数据未准备好前是一直阻塞住还是立即返回并设置errno为EAGAIN（+轮询检查）。

