并发模型
程序使用Reactor模型，并使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。

线程
一般而言，多线程服务器中的线程可分为以下基类：
	1、IO线程（负责网络IO）
	2、计算线程（负责复杂计算）
	3、第三方库所用线程
因为Web静态服务器计算量小，所以没有分配计算线程，减少跨线程分配的开销，让IO兼顾计算任务，每个线程一个事件循环，遵循One loop per thread.

并发模型
MainReactor只有一个，负责响应client的连接请求，并建立连接。在建立连接后用Round Robin的方式分配给某个SubReactor，因为设计到跨线程任务分配，所以要加锁，这里的锁由某个特定线程中的loop创建，只会被该线程和主线程竞争。
SubReactor可以有一个或者多个，每个SubReactor都会在一个独立线程中运行。
当主线程把新连接分配给了某个SubReactor,该线程此时可能正阻塞在多路选择器(epoll)里，怎么知道新连接的到来呢？这里使用eventfd进行异步唤醒，线程会从epoll_wait中醒来，得到活跃事件，进行处理。

epoll工作模式
epoll的触发模式在这里我选择了ET模式，ET要比LT复杂许多，它对用户提出了更高的要求，即每次读、必须读到不能再读(出现EAGAIN)，每次写，写到不能再写(出现EAGAIN)。而LT则简单的多，可以选择也这样做，也可以编程方便，比如每次只read一次。

定时器
每个SubReactor持有一个定时器，用于处理超时请求和长时间不活跃的连接。这里我的实现直接使用了stl里的priority_queue,底层是小根堆，并采用惰性删除的方式，事件的到来不会唤醒线程，而是每次循环到最后检查，如果超时了再删除，因为这里对超时的要求不会很高，如果此时线程忙，那么检查时间队列的间隔也会短，如果不忙，也给了超时请求更长的等待时间。
